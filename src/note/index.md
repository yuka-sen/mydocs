# 面试题知识点总结

## URL从输入到渲染过程都发生了什么？

#### 导航阶段

 首先浏览器将URL请求交给网络进程发起URL请求。然后去本地查找IP地址是否有缓存，如果没有的话，会发起dns查询。拿到映射后的IP地址发起正式的网络连接。接着会通过tcp三次握手建立网络连接，浏览器发起http请求，服务器将响应的数据放在响应体返回给浏览器，浏览器接收到数据开始解析。

#### 渲染阶段

- 解析dom树，解析css生成styleSheetes,两者合并生成layout tree，接着对布局树进行分层，然后就是图层绘制。
- 绘制好的图层交给合成线程处理成图块，图块经过光栅化处理生成位图，最后合成线程生成一个图块命令交给浏览器主进程进行显示。
  
## 有哪些方案可以减少回流和重绘

- 尽可能在DOM树的最末端改变class，集中样式到一个class上面进行修改，避免频繁修改dom节点样式
- 合理使用transfrom实现动画效果
- 使用documentfragment一次性插入
- 使用框架例如vue和react

## http2.0协议和http1.1
#### http1.1的特点
- 增加持久连接，默认设置connection：keep-alive
- 浏览器为每个域名最多可同时维持六个tcp持久连接
- 使用cdn实现域名分片机制
#### http1.1的缺点
- tcp慢启动
- 多条tcp连接会竞争宽带
- 队头阻塞（因为不能并行请求，当上一个请求没有完成，后面的请求就会被阻塞）
#### http2的特点
- 多路复用：一个域名只使用一个tcp长连接，并且支持多个请求并发。实现原理就是加入二进制分帧层，将数据转换成带有ID的帧，同一个请求的数据ID是一样的。解决了http1.1d对头阻塞的问题和宽带竞争
- 可以设置请求的优先级
- 服务器推送
- 对请求头和响应头进行了压缩
#### http2的缺点
- tcp队头阻塞
- tcp建立连接的延时

## 网络安全
#### xss攻击：
主要是一种通过网站漏洞注入第三方恶意脚本，窃取用户信息的行为
- 存储型xss攻击：黑客将恶意代码通过网站漏洞提交给服务器，服务器将恶意脚本存储起来，并在用户请求时发送出去，用户页面执行恶意脚本。
- 反射性xss攻击：黑客在用户页面讲恶意脚本发送到服务器（例如，作为参数发送），服务反射回来，参数作为恶意脚本被执行。
- dom型xss攻击：黑客在文件传输的过程中或者页面使用的过程中修改页面的数据。
#### xss攻击阻止方法
- 服务器对输入脚本进行过滤或者转码
- 充分利用csp
- 设置httponly属性
#### csrf攻击:
利用用户在登录目标站点的情况下，引诱用户打开第三方连接，在第三方站点向目标站点发起恶意请求的行为
#### csrf攻击阻止方法
- 设置cookie时带上sameSite选项（strict、lax、none）
- 通过请求头中的origin和referer验证请求的来源站点
- 服务器生成token，在请求的过程中需要携带token并校验


## 浏览器缓存
#### 强缓存（未修改的话返回200 并标识from memory 或者 from disk cache)
- 浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回
#### 相关头部字段（Cache-Control优先级更高）
- Cache-Control：属性值为max-age，并且在max-age的值内再次请求资源的话直接命中强缓存
- Expires：过期时间内再次请求的话
  
#### 协商缓存（未修改的话返回304）
- Etag/If-None-Match（优先级更高）：Etag的值事服务器发给前端的缓存验证码，再次请求相同资源时请求头中的If-None-Match的值就等于Etag并发送给服务器
- Last-Modify/If-Modify-Since：Last-modify是一个时间标识该资源的最后修改时间。当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。

## vite和webpack的区别
- 1.webpack冷启动需要将所有的文件进行一个编译、打包，这个过程是一个非常耗时的过程。而vite是利用了现代浏览器支持esmodule的特点，在冷启动的过程中，根据浏览器的请求动态传输所需要的资源文件。
- 2.在热更新的过程中，webpack是通过返回给 hmr runtime 一个mainfest的文件和更新的chuck.js，重新生成依赖关系，更新新模块。但是vite则不需要这个编译和重新分析依赖关系的过程，节省了时间。
- 3.webpack需要复杂的配置的工作，而vite内部会默认集成很多功能，是一个开箱即用的工具
  
## 前端性能指标与优化方法
### 常见性能指标
- first paint
- first content paint
- largest content paint
- first input delay
- Cumulative Layout Shift
- Time to First Byte
### 优化方法：
  #### 1.加快资源加载时间 ：
  - dns静态资源部署 
  - HTTP 压缩：服务器对资源文件包进行压缩 
  - 前端打包工具压缩 和 Tree Shaking
  - 减少http请求
  - 使用 dns-prefetch 减少 DNS 的查询时间
  - 使用 preconnect 提前建立连接
  - 使用 preload / prefetch 预先加载资源
  #### 2.加快资源渲染时间 ：
  - 减少阻塞渲染的因素（html节点数尽量少、节点嵌套深度尽量不要太深、css样式嵌套不易过深）
  - 图片懒加载 骨架屏 
  - 服务端渲染
  - 预渲染
#### 3.交互层面 ：
- 减少页面的回流重绘
- 防抖节流
- 虚拟列表
- web worker
- 大文件分片上传
#### 4.Vue 项目的优化 ：
- 使用v-show和v-once 、v-memo 减少页面组件重复渲染
- v-for使用独一无二的key值
- 路由懒加载 第三方库按需引入 
- 及时清除组件中的副作用



